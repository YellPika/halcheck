\section{Motivation}

\begin{frame}{\halcheck{} \textemdash{} Motivation}
  \textbf{Why} \halcheck{}? (and why not RapidCheck)?

  \begin{enumerate}
    \item \textbf{Simpler API}
    \item
    \item
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{\halcheck{} \textemdash{} Motivation \textemdash{} API}
  Most PBT frameworks are direct ports of \texttt{QuickCheck} or \texttt{Hedgehog}.

  These frameworks all consist of:

  \pause{}

  \bigskip{}

  \begin{columns}
    \column{0.5\textwidth}
    \textbf{A central generator data type:}
    \begin{minted}{haskell}
      --                  Source of
      --                ▿ randomness
      data Gen a = Gen (Random |→| Tree a)
      --   Tree of shrunk values ▵
    \end{minted}

    \pause{}

    \column{0.5\textwidth}
    \textbf{A set of basic combinators:}
    \begin{minted}{haskell}
      choose    |∷| (Int, Int) |→| Gen Int
      suchThat  |∷| (a |→| Bool) |→| Gen a |→| Gen a
      frequency |∷| [(Int, Gen a)] |→| Gen a
      |\ldots|
    \end{minted}
  \end{columns}

  \pause{}

  \bigskip{}

  \begin{itemize}
    \item Users must be comfortable reasoning about higher-order functions.
    \item Users must know the distinction between \emph{generator code} and \emph{non-generator code}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile,t]{\halcheck{} \textemdash{} Motivation \textemdash{} API}
  \textbf{Example:} \emph{Write a generator combinator that produces \mintinline{c++}{std::vector}s up to (but not including) a given length.}

  \begin{onlyenv}<+>
    \begin{minted}{c++}
      Gen<std::vector<int>> example(int N) {
        return gen::container<std::vector<int>>(
          *gen::inRange(0, N),
          gen::arbitrary<int>);
      }
    \end{minted}
  \end{onlyenv}

  \begin{onlyenv}<+>
    \begin{minted}{c++}
      Gen<std::vector<int>> example(int N) {
        return gen::container<std::vector<int>>(
          *gen::inRange(0, N), // WRONG
          gen::arbitrary<int>);
      }
    \end{minted}

    \textbf{Problem:} \mintinline{c++}{*gen::inRange(0, N)} is evaluated \emph{before} \mintinline{c++}{example} returns, resulting in a generator that always produces \mintinline{c++}{std::vector}s of the same length.
  \end{onlyenv}

  \begin{onlyenv}<+>
    \begin{minted}{c++}
      Gen<std::vector<int>> example(int N) {
        return gen::exec([=] {
          return gen::container<std::vector<int>>(
            *gen::inRange(0, N),
            gen::arbitrary<int>);
        });
      }
    \end{minted}

    \textbf{Solution:} Need to delay computation of \mintinline{c++}{*gen::inRange(0, N)} using \mintinline{c++}{gen::exec}.
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile]{\halcheck{} \textemdash{} Motivation \textemdash{} API}
  \begin{itemize}
    \item Generators should only be invoked (\mintinline{c++}{operator *}) in the correct context.
    \item Haskell's type system completely rules out this kind of error.
    \item C++'s type system is not powerful enough!
    \item Problem goes away if we simply \emph{get rid of the generator type} and \emph{just write first-order functions}!
  \end{itemize}

  \begin{minted}{c++}
    std::vector<int> example(int N) {
      // container(int, () → int) → std::vector<int>
      return gen::container<std::vector<int>>(
        gen::range(0, N),
        gen::arbitrary<int>);
    }
  \end{minted}
\end{frame}

\begin{frame}{\halcheck{} \textemdash{} Motivation}
  \textbf{Why} \halcheck{}? (and why not RapidCheck)?

  \begin{enumerate}
    \item Simpler API
    \item \textbf{Support for test-case generation strategies}
    \item
  \end{enumerate}
\end{frame}

\begin{frame}{\halcheck{} \textemdash{} Motivation \textemdash{} Strategies}
  There are various desirable strategies for generating data:
  \begin{itemize}
    \item Exhaustive (SmallCheck/LeanCheck)
    \item Learning-based (RLCheck)
    \item Coverage-guided (FuzzTest)
    \item Random (almost everything)
  \end{itemize}

  Most PBT frameworks (including RapidCheck) use a \textbf{fixed strategy}.
\end{frame}

\begin{frame}[fragile]{\halcheck{} \textemdash{} Motivation \textemdash{} Strategies}
  \halcheck{} provides combinators for specifying strategies:

  \begin{minted}{c++}
    //   random(int) → strategy
    // ▿ Executes random test cases forever or until a bug is found.
    test::random(seed)([] { run_test(); });
  \end{minted}

  \pause{}

  \begin{minted}{c++}
    //   limited(strategy, int) → strategy
    // ▿ Executes at most 100 test cases.
    test::limited(test::random(), 100)([] { run_test(); });
  \end{minted}

  \pause{}

  \begin{minted}{c++}
    //   shrinking(strategy) → strategy
    // ▿ Performs test-case shrinking if a bug is found.
    test::shrinking(test::random())([] { run_test(); });
  \end{minted}
\end{frame}

\begin{frame}{\halcheck{} \textemdash{} Motivation}
  \textbf{Why} \halcheck{}? (and why not RapidCheck)?

  \begin{enumerate}
    \item Simpler API
    \item Support for test-case generation strategies
    \item \textbf{Better space complexity}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{\halcheck{} \textemdash{} Motivation \textemdash{} Space Complexity}
  \begin{columns}[t]
    \column{0.5\textwidth}
    \textbf{How does shrinking work?}

    \bigskip

    \begin{minted}{haskell}
    data Gen a = Gen (Random |→| Tree a)
    \end{minted}

    \bigskip

    Internally, every generator returns a "shrink tree" of values.

    \bigskip

    Shrink trees can be \textbf{very large} so they must be computed lazily.

    \column{0.5\textwidth}
    \textbf{Shrink tree for a list:}
    \begin{tikzpicture}
      \node{[1, 0, 1]}
      child {node {[0, 1]}}
      child {node {[1, 1]}}
      child {node {[1, 0]}
          child {node {[0]}
              child {node {[]}}}
          child {node {[1]}}
          child {node {[0, 0]}}}
      child {node {[0, 0, 1]}}
      child {node {[1, 0, 0]}}
      ;
    \end{tikzpicture}
  \end{columns}

  \pause{}

  \textbf{This implementation strategy does not work for C++!}
\end{frame}

\begin{frame}[fragile]{\halcheck{} \textemdash{} Motivation \textemdash{} Space Complexity}
  \textbf{Example:}
  \begin{minted}{c++}
    auto xs = *gen::arbitrary<std::vector<int>>();
    auto x  = *gen::elementOf(xs);
  \end{minted}

  \pause{}

  \begin{itemize}
    \item Shrinking \mintinline{c++}{x} requires picking a different element of \mintinline{c++}{xs}.
          \pause{}

    \item Shrinking is performed \emph{after} the test case has finished (\mintinline{c++}{xs} no longer exists)!
          \begin{itemize}
            \item Not a problem in languages with automatic memory management.
          \end{itemize}
          \pause{}

    \item \textbf{\mintinline{c++}{gen::elementOf} must store a copy of \mintinline{c++}{xs}} in order to avoid creating a dangling reference.
          \pause{}
  \end{itemize}

  \textbf{Conclusion:} \textit{all combinators must make copies of their arguments!}

  \textbf{Problem:} by default, copies in C++ are deep ($\mathcal{O}(n)$ instead of $\mathcal{O}(1)$).
\end{frame}

\begin{frame}[fragile]{\halcheck{} \textemdash{} Motivation \textemdash{} Space Complexity}
  \begin{columns}[t]
    \column{0.47\textwidth}
    \textbf{Generators cannot return references:}

    \begin{minted}{c++}
      // Generates a random reference
      // to an element of xs.
      rc::Gen<int &> referenceOf(??? xs);

      // Example: assign a
      // random element to 0.
      *referenceOf(xs) = 0;
    \end{minted}

    What type should \mintinline{c++}{referenceOf} have?

    \pause{}

    \column{0.53\textwidth}
    \textbf{\mintinline{c++}{exec} arguments must capture by value:}
    \begin{minted}{c++}
      auto bound  = *gen::arbitrary<int>();
      auto ranges = *gen::container<...>(
        gen::exec([&] {
          // bound does not exist
          // during shrinking!
          auto min = *gen::inRange(0, bound);
          auto max = *gen::inRange(min, bound);
          return std::make_pair(min, max);
        }));
    \end{minted}
  \end{columns}
\end{frame}

\begin{frame}{\halcheck{} \textemdash{} Motivation \textemdash{} Space Complexity}
  \begin{itemize}
    \item \mintinline{c++}{halcheck} \textbf{never} makes copies of generated data.
    \item \mintinline{c++}{halcheck} \textbf{only} records decision made during the generation process.
    \item All the previous examples work in \mintinline{c++}{halcheck} without any unnecessary copying!
  \end{itemize}
\end{frame}

\begin{frame}{\halcheck{} \textemdash{} Motivation}
  \textbf{Why} \halcheck{}? (and why not RapidCheck)?

  \begin{enumerate}
    \item Simpler API
    \item Support for test-case generation strategies
    \item Better space complexity
          \pause{}
  \end{enumerate}
\end{frame}
