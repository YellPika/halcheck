\section{Motivation}

\begin{frame}<1>[label=motivation]{\halcheck{} --- Motivation}
  \begin{block}{Why \halcheck?}
    \begin{enumerate}
      \item<alert@1> Simpler API
      \item<alert@2> Support for test-case generation strategies
      \item<alert@3> Better space complexity
    \end{enumerate}
  \end{block}
\end{frame}

\begin{frame}[fragile]{\halcheck{} --- Motivation --- API}
  All PBT frameworks are direct ports or descendants of QuickCheck. These frameworks all consist of:

  \bigskip{}
  \pause{}

  \begin{columns}
    \begin{column}{0.4\textwidth}
      \begin{block}{A central generator data type:}
        \begin{minted}{haskell}
          --                  Source of
          --                ▿ randomness
          data Gen a = Gen (Random |→| Tree a)
          --   Tree of shrunk values ▵
        \end{minted}
      \end{block}
    \end{column}

    \pause{}

    \begin{column}{0.5\textwidth}
      \begin{block}{A set of basic combinators:}
        \begin{minted}{haskell}
          choose    |∷| (Int, Int) |→| Gen Int
          suchThat  |∷| (a |→| Bool) |→| Gen a |→| Gen a
          frequency |∷| [(Int, Gen a)] |→| Gen a
          |\ldots|
        \end{minted}
      \end{block}
    \end{column}
  \end{columns}

  \pause{}

  \bigskip{}

  \begin{itemize}
    \item Users must be comfortable reasoning about higher-order functions.
    \item Users must ensure generators are only invoked in the \alert{correct context}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile,t]{\halcheck{} --- Motivation --- API}
  \textbf{Example:} \emph{Write a generator combinator that produces \mintinline{c++}{std::vector}s up to (but not including) a given length.}

  \begin{onlyenv}<+>
    \begin{minted}{c++}
      // RapidCheck
      Gen<std::vector<int>> example(int N) {
        return gen::container<std::vector<int>>(
          *gen::inRange(0, N),
          gen::arbitrary<int>);
      }
    \end{minted}

    \begin{minted}{haskell}
      -- QuickCheck
      example n = vectorOf (choose (0, n - 1)) arbitrary
    \end{minted}
  \end{onlyenv}

  \begin{onlyenv}<+>
    \begin{minted}{c++}
      // RapidCheck
      Gen<std::vector<int>> example(int N) {
        return gen::container<std::vector<int>>(
          *gen::inRange(0, N), // WRONG (no compiler error)
          gen::arbitrary<int>);
      }
    \end{minted}

    \begin{minted}{haskell}
      -- QuickCheck         ▿ WRONG (compiler error)
      example n = vectorOf (choose (0, n - 1)) arbitrary
    \end{minted}

    \textbf{Problem:} \mintinline{c++}{example(N)} always produces \mintinline{c++}{std::vector}s of the same length.
  \end{onlyenv}

  \begin{onlyenv}<+>
    \begin{columns}[T]
      \column{0.55\textwidth}
      \begin{minted}{c++}
        // RapidCheck
        Gen<std::vector<int>> example(int N) {
          return gen::exec([=] {
            return gen::container<std::vector<int>>(
              *gen::inRange(0, N),
              gen::arbitrary<int>);
          });
        }
      \end{minted}

      \column{0.35\textwidth}
      \begin{minted}{haskell}
        -- QuickCheck
        example n = do
          i |←| choose (0, n - 1)
          vectorOf i arbitrary
      \end{minted}
    \end{columns}

    \textbf{Solution:} Delay computation of \mintinline{c++}{*gen::inRange(0, N)} using \mintinline{c++}{gen::exec}.
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile]{\halcheck{} --- Motivation --- API}
  \begin{itemize}
    \item \textbf{Problem:} Need to ensure generators are only invoked in the correct context.
          \begin{itemize}
            \item Haskell's type system ensures this always happens.
            \item C++'s type system can provide no such guarantee!
          \end{itemize}
          \pause{}
    \item \textbf{Solution:} Get rid of the generator type!
          \begin{itemize}
            \item All code is written in the generator context.
            \item Bonus: fewer higher-order functions.
          \end{itemize}
  \end{itemize}

  \begin{minted}{c++}
    // halcheck
    std::vector<int> example(int N) {
      // container(int, () → int) → std::vector<int>
      return gen::container<std::vector<int>>(
        gen::range(0, N),
        gen::arbitrary<int>);
    }
  \end{minted}
\end{frame}

\againframe<2>{motivation}

\begin{frame}{\halcheck{} --- Motivation --- Strategies}
  There are various desirable strategies for generating data:
  \begin{itemize}
    \item Random (almost everything)
    \item Enumerative (SmallCheck/LeanCheck) \pause{}
    \item Learning-based (RLCheck)
    \item Coverage-guided (FuzzTest) \pause{}
  \end{itemize}

  Most PBT frameworks (and all C++ PBT frameworks) use a \alert{fixed strategy}.
\end{frame}

\begin{frame}[fragile]{\halcheck{} --- Motivation --- Strategies}
  \halcheck{} provides combinators for specifying strategies:

  \begin{minted}{c++}
    //   random(int) → strategy
    // ▿ Executes random test cases forever or until a bug is found.
    test::random(seed)([] { /* test code */ });
  \end{minted}

  \pause{}

  \begin{minted}{c++}
    //   limited(strategy, int) → strategy
    // ▿ Executes at most 100 test cases.
    test::limited(test::random(), 100)([] { /* test code */ });
  \end{minted}

  \pause{}

  \begin{minted}{c++}
    //   shrinking(strategy) → strategy
    // ▿ Performs test-case shrinking if a bug is found.
    test::shrinking(test::random())([] { /* test code */ });
  \end{minted}

  \pause{}

  (Intended for advanced users.)
\end{frame}

\againframe<3>{motivation}

\begin{frame}[fragile]{\halcheck{} --- Motivation --- Space Complexity}
  \begin{columns}[t]
    \column{0.5\textwidth}
    \begin{block}{How does shrinking work?}
      \bigskip

      Internally, every generator is a function returning a ``shrink tree'' of values.

      \bigskip

      \begin{minted}{haskell}
      data Gen a = Gen (Random |→| Tree a)
      \end{minted}

      \bigskip

      Shrink trees can be \alert{very large} so they must be computed lazily.
    \end{block}

    \column{0.5\textwidth}
    \begin{block}{Shrink tree for a list:}
      \begin{tikzpicture}
        \node{[1, 0, 1]}
        child {node {[0, 1]}}
        child {node {[1, 1]}}
        child {node {[1, 0]}
            child {node {[0]}
                child {node {[]}}}
            child {node {[1]}}
            child {node {[0, 0]}}}
        child {node {[0, 0, 1]}}
        child {node {[1, 0, 0]}}
        ;
      \end{tikzpicture}
    \end{block}
  \end{columns}

  \pause{}

  This implementation strategy \alert{does not work for C++!}
\end{frame}

\begin{frame}[fragile]{\halcheck{} --- Motivation --- Space Complexity}
  \begin{block}{Example:}
    \begin{minted}{c++}
      auto xs = *gen::arbitrary<std::vector<int>>();
      auto x  = *gen::elementOf(xs);
    \end{minted}
  \end{block}

  \pause{}

  \begin{itemize}
    \item To shrink \mintinline{c++}{x}, RapidCheck must pick a different element of \mintinline{c++}{xs}.
          \pause{}

    \item Shrinking is performed \emph{after} the test case has finished (\alert{\mintinline{c++}{xs} no longer exists})!
          \begin{itemize}
            \item Not a problem in languages with automatic memory management.
          \end{itemize}
          \pause{}

    \item \mintinline{c++}{gen::elementOf} must store a copy of \mintinline{c++}{xs} in order to avoid creating a dangling reference.
          \pause{}
  \end{itemize}

  \textbf{Conclusion:} all combinators (with shrinking behaviour) must make copies of their arguments!

  \pause{}

  \textbf{Problem:} by default, copies in C++ are deep ($\mathcal{O}(n)$ instead of $\mathcal{O}(1)$).
\end{frame}

\begin{frame}[fragile]{\halcheck{} --- Motivation --- Space Complexity}
  \begin{columns}[t]
    \column{0.47\textwidth}
    \begin{block}{Generators cannot return references:}
      \begin{minted}{c++}
        // Generates a random reference
        // to an element of xs.
        rc::Gen<int &> referenceOf(??? xs);

        // Example: assign a
        // random element to 0.
        *referenceOf(xs) = 0;
      \end{minted}

      What type should \mintinline{c++}{referenceOf} have?
    \end{block}

    \pause{}

    \column{0.53\textwidth}
    \begin{block}{\mintinline{c++}{exec} arguments must capture by value:}
      \begin{minted}{c++}
        auto bound  = *gen::arbitrary<int>();
        auto ranges = *gen::container<...>(
          gen::exec([&] {
            // bound does not exist
            // during shrinking!
            auto min = *gen::inRange(0, bound);
            auto max = *gen::inRange(min, bound);
            return std::make_pair(min, max);
          }));
      \end{minted}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}{\halcheck{} --- Motivation --- Space Complexity}
  \mintinline{c++}{halcheck} is inspired by work on \alert{internal shrinking}.
  \begin{itemize}
    \item Motto: shrink inputs, not outputs!
    \item Data is regenerated, never copied.
  \end{itemize}

  \textbf{Note:} \mintinline{c++}{halcheck} does \alert{not} use internal shrinking.
  \begin{itemize}
    \item Users have full control over shrinking.
  \end{itemize}
\end{frame}

\againframe<4>{motivation}
